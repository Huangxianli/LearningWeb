# 响应事件
## 添加事件处理函数
1. 在组件内声明函数 a，
2. 在函数 a 内处理逻辑
3. 添加到 JSX 中 onXXX={a}
> 注意：如果在{}中调用了函数，则会在渲染的过程中立即调用

### 在事件处理函数中读取 props
事件处理函数一般声明于组件内，这样可以访问组件的 props。

```jsx
function Test(props) {
  function handleClick() {
    alert(props.data);
  }
  return (
    <>
      <button onClick={handleClick}>点击</button>
    </>
  )
}
```

### 将事件处理函数作为props和传递
在父组件中定义子组件的事件处理函数，然后传递给子组件，再在子组件中将该prop作为事件处理函数绑定在子组件的JSX上面
> 注意：事件处理函数会作为props传递给子组件
> 例如： <Father onClick={() => {}}>，在子中可以通过props.onClick获取到
> 这是一种处理反向数据流的方式

### 命名事件处理函数prop
内置的组件只支持*浏览器事件*，按照惯例事件处理函数props一般*以on开头，后面跟一个大写字母*

## 事件传播
沿着向上冒泡，触发了子的点击事件，也会触发父的点击事件，子和父的点击事件的事件处理函数都会执行

*在React中所有的事件都会冒泡，除了onScroll*

### 阻止事件传播
e.stopPropagation();
> 注意：子即使没有绑定点击事件，点击了子，父绑定的点击事件也会触发

即使子阻止了事件传播，但是父还是希望捕获到，可以在父上使用 onClickCapture。
这样在点击子的时候，会先执行父的事件回调，再执行子的事件回调

#### 事件传播
1. 点击子，从父（Capture）这里向下传播，调用所有Capture的回调（包括子自己）
2. 执行被点击的子的该事件回调处理函数
3. 向上传播，调用所有的该事件（子没有e.stopPropagation()的情况下）

### 传递处理函数作为事件传播的替代方案
将父组件的事件回调作为子组件的prop传递，在子组件的事件回调中，调用该prop，这样的话，就不用依赖事件冒泡

### 阻止默认行为
e.preventDefault();


## 事件处理函数是执行副作用的最佳位置
与渲染函数不同，事件处理函数不需要是纯函数
事件处理函数不是在渲染的时候执行的，所以不要求是纯函数，是处理副作用的最佳位置
