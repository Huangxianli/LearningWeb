# 使用自定义 Hook 复用逻辑

## 自定义 Hook：组件间共享逻辑

即使是有不同的视觉外观，但是依旧想要复用组件之间的逻辑

### 从组件中提取自定义 Hook

移除组件之间重复的部分，移入到自定义函数中
组件中描述的是想要做什么，而不是怎么做，使用自定义 Hook 时，可以隐藏式如何处理外部系统或者浏览器 API 等一些细节。组件内部的代码表达的是目标而不是具体实现

### Hook 的名称必须永远以 use 开头

React 应用由组件构成，组件有内置或者自定义的 Hook 构成
自定义 Hook 命名公约：

1. React 组件名称必须以大写字母开头，返回一些 React 能够显示的内容，如 JSX
2. Hook 的名称必须以 use 开头，然后紧跟一个大写字母。Hook 可以返回任何值

**并不是所有渲染期间调用的函数都应该以 use 前缀开头，也就是说并不是所有渲染期间的调用的函数都是 Hook**
没有调用 Hook 的函数不用变成 Hook，不需要以 use 开头，但是只要里面调用了 Hook，就要以 use 开头

### 自定义的 Hook 共享的是状态逻辑，而不是状态本身

在两个组件中调用同一个 Hook，如果 hook 中有状态，那么该状态在两个组件中表现的应该是独立的
如果要在多个组件中共享 state，应该将变量提升并且传递

### 在 Hook 之间传递响应值

**组件和自定义的 Hook 都应该是纯函数**

## 什么时候使用自定义 Hook

没必要对每段重复的代码都提取自定义 Hook
每当写 Effect 的时候，考虑一下把它包裹在自定义 Hook 是否更清晰。不应该经常使用 Effect，把 Effect 包裹进自定义 Hook 可以更准确表达目的以及数据在里面是如何流动的

例如，很多请求他的数据和处理逻辑类似，这个时候，介可以将请求封装成一个 Hook，url 就通过入参来传入

让自定义 Hook 专注于具体的高级用例：

- 清晰的功能
- 清晰的同步方
- 避免创建和使用作为 useEffect API 本身的替代品和 wraooer 的自定义“生命周期” Hook

如果在正在编写 Effect，**先直接使用现有的 React API 开始，然后再为不同的高级用例提取自定义 Hook（非必要）**
好的自定义 Hook 通过限制功能使代码调用更具声明性

### 自定义 Hook 帮助你迁移到更好的模式

这是把 Effect 包裹进自定义 Hook 有益的另一个原因：

1. 你让进出 Effect 的数据流非常清晰
2. 你让组件专注于目标，而不是 Effect 的准确实现
3. 当 React 增加新特性时，你可以在不修改任何组件的情况下移除这些 Effect
