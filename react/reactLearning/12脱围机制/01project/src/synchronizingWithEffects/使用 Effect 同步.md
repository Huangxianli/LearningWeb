# 使用 Effect 同步

组件需要与外部系统同步

## 什么是 Effect，它与事件（event）有何不同？

React 组件中的两种逻辑类型

1. 渲染逻辑代码（必须是纯粹的）
2. 事件处理程序（不需要保持纯粹，很适合用来处理副作用）

但是有的时候这些不一定能够满足条件，_Effect 允许指定由渲染本身而不是特定事件引起的副作用_
Effect 在**提交结束后、页面更新后**运行，这个时候是 React 组件与外部系统同步的最佳时机

## 你可能不需要 Effect

Effect 通常用于暂时的跳出 React，用来与外部进行同步
如果想用 Effect 仅根据其他状态调整某些状态，那么可能不需要 Effect

## 如何编写 Effect

### 第一步：声明 Effect

```jsx
import { useEffect } from 'react';
function Component() {
  useEffect(() => {
    // 每次渲染之后，都会执行这里的代码
  });
}
```

useEffect 在提交阶段执行（react19 是在提交之后执行），也就是在渲染之后执行，如果在其中更新 state，可能会导致死循环
在组件重新渲染时，React 会先更新页面，然后再运行 useEffect 中的代码。换句话说，**useEffect 会“延迟”一段代码的运行，直到渲染的结果反应在页面上**

### 第二步：指定 Effect 依赖

默认情况下，Effect 会在**每次**渲染提交之后运行，但这往往不是想要的

```jsx
import { useEffect } from 'react';
function Component() {
  useEffect(() => {}, []);
  /**
   * 传入 [变量]，在变量与上次渲染的值不同的时候，才会重新执行 （Object.is()），只有所有的依赖都一上一次渲染时值相同的时候才不会触发执行
   * 传入 []，只会在挂载之后执行一次
   * 什么都不传，每次渲染后都会执行
   */
  // 不能随意的选择依赖项项，代码内依赖了，但是没有写入依赖项里面，Linter 会报错，如果不希望该依赖想改变的时候发吗重新执行的话，应该调整 Effect 本身，使得其不再需要改依赖
}
```

_Effect 依赖数组可以省略 ref_，这是应为在每次渲染中调用同一个 useRef 时，总是能获取到相同的对象，ref 在表面上是不会变的
_setter 函数也是这样的_

### 第三步：按需添加清理（cleanup）函数

```jsx
import { useEffect } from 'react';
function Component() {
  useEffect(() => {
    return () => {};
    // 在组件被卸载，或者重新执行 Effect 之前，都会调用 cleanup 函数
  }, []);
}
```

## 如何处理在开发环境中 Effect 执行两次？

**在开发环境中，React 有意重复挂载组件，如果由这个触发的问题，应该思考“如何修复 Effect 以让他在重新挂载后能正常工作”，而不是“如何让 Effect 只执行一次”**
**不要使用 ref 来防止触发 Effect**

### 控制非 React 组件

有依赖项，但是依赖项在两次中不变，不用处理
没有依赖项，实现清理函数

### 订阅事件

如果 Effect 中订阅了事件，那么清理函数就应该退订这些事件

### 触发动画

如果 Effect 中触发了一下动画，那么清理函数中要将这些动画重置为初始状态

### 获取数据

如果在 Effect 中请求了数据，那么在清理函数中，要进行终止请求，或者忽略请求结果
使用 useEffect 中定义的变量，在清理函数中，设置为另一个值，如果下一次执行 Effect 的时候，又重置为初始值，在使用数据的时候，如果变量为另一个值，则使用该数据（相当于已经发起了第二次请求）

### 发送分析报告

在请求页面发送日志

- 可以不放在 Effect 中，放在路由处理中（如果放在 Effect，不可避免的会进行两次请求，收集到两次数据）
- 可以暂时取消严格模式

### 初始化应用时不需要使用 Effect 的情形

如果某些逻辑只是在应用启动的时候运行一次，那么不应该将这些逻辑放在 Effect 中，可以放在组件之外

### 不要在 Effect 中执行购买商品一类的操作

这一类的操作都应该是事件驱动，而不是组件渲染驱动
