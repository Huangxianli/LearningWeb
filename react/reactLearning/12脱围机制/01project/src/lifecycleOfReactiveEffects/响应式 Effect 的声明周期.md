# 响应式 Effect 的声明周期

Effect 和组件有不同的声明周期。组件可以挂载、更新、卸载，Effect 只能做两件事：开始同步某些东西、停止同步它

## Effect 的声明周期

React 组件的声明周期

- 组件添加到屏幕时，进行组件的*挂载*
- 组件接收到新的 props 或 state 时，进行*更新*
- 组件从屏幕上移除时，进行组件的*卸载*

Effect 应该尝试从组件的声明周期中跳出来，独立的进行思考
**Effect 描述的是：如何将外部系统与当前的 props 和 state 同步**
指定：如何开始同步，如何结束同步
组件挂载时开始同步，组件卸载时停止同步，在组件保持挂载状态的同时，可能还会进行多次的开始和停止同步

### 为什么同步可能需要多次进行

保持挂载期间，可能会有多个状态，一个状态可能就要与外界同步一次

### React 如何重新同步 Effect

先停止上一次的同步（调用上一次 Effect 返回的清理函数），在开始这一次的同步（执行这一次的 Effect）

### 从 Effect 的角度思考

**始终专注于单个启动/停止周期。无论是组件挂载、更新还是卸载，都不应该有影响。只需要描述如何开始同步、如何结束同步。如果做的好，Effect 将能够在需要时始终具备启动和停止的弹性**

### React 如何验证 Effect 可以重新进行同步

React 通过在开发环境中立即强制 Effect 重新进行同步来验证能否重新同步（在开发环境中，额外的启动和停止 Effect 一次，以检查是否正确实现了清理功能）
实际上，Effect 重新进行同步的主要原因是它所使用的某些数据发生了变化

### React 如何知道需要重新进行 Effect 的同步

依赖列表
每次组件重新渲染之后，React 都会查看传递的依赖数组。如果数组中的任何值与上一次渲染时在相同位置的值不同（使用 `Object.is()` 比较），React 将重新同步 Effect

### 每个 Effect 表示一个独立的同步过程

如果两个过程是相互独立的，应该放在两个 Effect 里面。假如拆开后，删除其中一个不会影响另一个，那么就拆开

## Effect 会“响应”于响应式值

**在组件内部声明的 state、props 和其他值都是响应式的，因为它们是在渲染过程中计算的，并且参与了 React 的数据流**

### 没有依赖项的 Effect 的含义

空的 [] 依赖表明，只在组件挂载的时候同步一次，组件卸载的时候停止同步一次，在保持挂载中，不会再进行同步

### 在组件主体中声明的所有变量都是响应式的

props 和 state 并不是唯一的响应式值。从它们计算出的值也是响应式的。
如果 props 和 state 发生变化，组件将重新渲染，依赖它们计算出的值也会重新计算，所以，如果 Effect 中使用的组件主题中的所有变量都要放在依赖列表中
**组件内部的所有值（包括 props、state 和组件体内的变量）都是响应式的。任何响应式值都可以在重新渲染时发生变化，所以需要将响应式值包括在 Effect 的依赖项中。**

全局变量不能作为依赖项，ref.current 也不能作为依赖项，但是 ref 是可以的

### React 会验证是否将每个响应式值都指定为了依赖项

### 当你不想进行重新同步时该怎么办

如果不会应为重新渲染而改变，可以将其移动到组件外的，或者将其移入到 Effect 中定义

不能选择依赖项，依赖项必须包括 Effect 中读取的每一个响应式值。有时会导致陷入死循环、过于频繁的同步 Effect 的问题

- 检查 Efeect 是否代表了独立的同步过程，如果没有同步任何信息，那该 Effect 可能是不必要的；如果尽心了几个独立的同步，拆分开来
- 如果想读取 props 或 state 的最新值，但又不想对其做出反应并重新同步 Effect，可以将 Effect 拆分为具有反应性的部分（保留在 Effect 中）和非反应性的部分（提取为名为 “Effect Event” 的内容）
- 避免将对象和函数作为依赖项。如果在渲染过程中创建对象和函数，然后在 Effect 中读取它们，它们将在每次渲染时都不同。这将导致 Effect 每次都重新同步
