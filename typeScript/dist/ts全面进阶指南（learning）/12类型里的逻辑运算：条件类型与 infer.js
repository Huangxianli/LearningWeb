function test() {
    console.log('--- 类型里的逻辑运算：条件类型与 infer ---------------------------------------------');
    test1();
    test2();
    test3();
}
;
/**
 * 条件类型基础
 * 对于能够进行赋值的变量，不要求他们变量的类型是完全相等的，只需要具有兼容性
 *
 * 记住：泛型参数的实际类型会在 实际调用 时才被填充（类型别名中显式传入，或者函数中隐式提取）
 */
function test1() {
    console.log('---test1---------------------------------------------');
    // 两个参数都使用了泛型参数 T，在使用的时候，T 会被填充为一个联合类型
    const fun1 = function (x, y) {
        return x + y; // 这里加 as 是因为使用连个参数定义为 T 泛型类型，在没有执行该函数的时候，其实是不能将 T 类型缩小范围的，x 和 y 的类型都是 （string | number） 的子类型，相当于 (string + number) + (string | number)，如果不加上 any 其中一个会报错
    };
    // fun1(1, '12'); // 两个参数设置的都是 T 类型，但是 1 和 '12' 两者 并不兼容，所以会报错
    // 在 x 传入 1 的时候，满足了 T extends number， 后面的参数也要满足 T extends number，传入‘12’的时候，不满足该条件，所以会报错
    fun1(1, '12'); // 这样又不报错，这和函数的泛型推断策略有关系
    const a = fun1(1, 2); // a: 1 | 2； T 被自动的推导为 1 | 2 的联合类型
    const fun2 = function (x, y) {
        return x + y;
    };
    const b = fun2(1, 2); // b number
}
;
/**
 * infer 关键字在条件类型中提取类型的一部分信息
 * infer 只能在条件类型中使用
 */
function test2() {
    console.log('---test2---------------------------------------------');
    let swap2_1 = [2]; // 根据传入的内容，只能是 [2]，如果不是的话，会报错
    let arr2_1 = [123, 12, 2, 231];
    // 这里要加上 & string
}
;
/**
 * 分布式条件类型
 * 参数类型是联合类型，且类型参数是通过泛型的方式传入的，条件类型中的泛型 不能 被包裹，这样就产生了分布式条件类型
 * 同时要注意一下 never 作为参数传递的情况，如果没有参数没有被包裹，extends 会返回 never（这是特殊情况中的特殊情况）
 *
 * 对于属于裸类型参数（作为泛型参数，但是在 extends 语句中没有被包裹的）的检查类型，条件类型会在实例化时期自动分发到联合类型上（以 | 为界限，拆分后一个一个去执行）
 *
 * 如果不是作为类型参数的话，不会分发，也就是符合我们认为的常规的 联合类型的 extends 判断
 * 如果作为参数，但是包裹了，也不会分发
 */
function test3() {
    console.log('---test3---------------------------------------------');
}
;
export default test;
