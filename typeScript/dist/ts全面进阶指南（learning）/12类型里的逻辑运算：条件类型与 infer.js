function test() {
    console.log('---类型里的逻辑运算：条件类型与 infer ---------------------------------------------');
    test1();
    test2();
    test3();
}
;
/**
 * 条件类型基础
 * 对于能够进行赋值的变量，不要求他们变量的类型是完全相等的，只需要具有兼容性
 */
function test1() {
    console.log('---test1---------------------------------------------');
    // 两个参数都使用了泛型参数 T，在使用的时候，T 会被填充为一个联合类型
    const fun1 = function (x, y) {
        return x + y;
    };
    // fun1(1, '12'); // 两个参数设置的都是 T 类型，但是 1 和 '12' 两者 并不兼容，所以会报错
    // 在 x 传入 1 的时候，满足了 T extends number， 后面的参数也要满足 T extends number，传入‘12’的时候，不满足该条件，所以会报错
    const a = fun1(1, 2); // a: 1 | 2； T 被自动的推导为 1 | 2 的联合类型
    const fun2 = function (x, y) {
        return x + y;
    };
    const b = fun2(1, 2); // b number
}
;
/**
 * infer 关键字在条件类型中提取类型的一部分信息
 * infer 只能在条件类型中使用
 */
function test2() {
    console.log('---test2---------------------------------------------');
}
;
/**
 * 分布式条件类型
 * 参数类型是联合类型，且类型参数是通过泛型的方式传入的，条件类型中的泛型不能被包裹，这样就产生了分布式条件类型
 */
function test3() {
    console.log('---test3---------------------------------------------');
}
;
export default test;
