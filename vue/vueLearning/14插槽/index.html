<!DOCTYPE html>
<html lang="zh">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>插槽</title>
</head>

<body>
  <div id="root"></div>
  <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
  <script>
    /**
     * 匿名插槽及其默认内容
    */
    const ChildComponent1 = {
      props: {
      },
      data: vm => ({
      }),
      computed: {
      },
      methods: {
      },
      watch: {
      },
      template:
        `
        <div>
          <div>ChildCompoent1</div>
          <slot>插槽的默认内容，该内容是可选的</slot>
        </div>
        `
      ,
    };


    /**
     * 具名插槽使得一个组件中可以使用多个插槽
     * 如果default的内容没有写v-solt则会自动收集所有散落的内容，加载到default对应的slot上
     * 如果加了v-slot:default则只取最后一个v-slot:default，其他v-slot:other的也是一样，只取最后一个
     * v-slot要使用在<template>上，只有一种情况例外
    */
    const ChildComponent2 = {
      props: {
      },
      data: vm => ({
      }),
      computed: {
      },
      methods: {
      },
      watch: {
      },
      template:
        `
        <div>
          <div>ChildComponent2</div>
          <div>
            <div>下面是slot first 的内容</div>
            <slot name="first"></slot>
          </div>
          <br />
          <div>
            <div>下面是solt second 的内容</div>
            <slot name="second"></slot>
          </div>
          <br />
          <div>
            <div>下面是slot default 的内容</div>
            <slot></slot>
          </div>
        </div>
        `
      ,
    };

    /**
     * 作用域插槽使得符组件可以直接访问子组件才有的数据
    */
    const ChildComponent3 = {
      props: {
      },
      data: vm => ({
        userInfo: {
          name: 'testName',
          age: 12,
        },
      }),
      mounted () {
        setTimeout(() => {
          this.userInfo = {};
        }, 1000); // 这里会触发重新渲染，作用域插槽会获取最新的值
      },
      computed: {
      },
      methods: {
      },
      watch: {
      },
      template:
        `
        <div>
          <div>ChildComponent3</div>
          <div>作用域插槽</div>
          <!-- 这种写法 user1 = userInfo 并将user1塞入一个对象中 -->
          <slot name="user" v-bind:user1="userInfo"></slot>
          <!--这里userInfo的改变会触发重新渲染，作用域插槽会获取最新的值-->
        </div>
        `
      ,
    };

    const ChildComponent4 = {
      data () {
        return {
          data1: '1'
        }
      },
      mounted () {
        setTimeout(() => { this.data1 = '2' }, 3000);
      },
      template:
        `
        <div>{{data1}}</div>
        `,
    }

    new Vue({
      el: '#root',
      data: vm => ({
        data1: '3',
      }),
      components: {
        ChildComponent1,
        ChildComponent2,
        ChildComponent3,
        ChildComponent4
      },
      mounted () {
        setTimeout(() => {
          this.data1 = '4';
        }, 2000);
      },
      template:
        `
        <div>
          <ChildComponent1 />
          <ChildComponent1>使用自己的内容覆盖插槽中的默认内容</ChildComponent1>
          <hr />

          <ChildComponent2>
            <div>default的内容1</div>
            <template v-slot:first>
              传入 slot first的内容
            </template>
            <div>default的内容2</div>
            <template v-slot:second>
              传入 slot second的内容1
            </template>
            <template v-slot:second>
              传入 slot second的内容2
            </template>
            <template v-slot:default>
              <div>default的内容3</div>
              <div>{{data1}}</div>
              <ChildComponent4 />
            </template>
          </ChildComponent2>
          <hr />

          <ChildComponent3>
            <template v-slot:user="userInfo">
              {{userInfo}}
            </template>
          </ChildComponent3>
        </div>
        `
      ,
    });
  </script>
</body>

</html>