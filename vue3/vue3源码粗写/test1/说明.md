# reactive 和 effect
+ reactive 让数据变成响应式的（数据）
+ effect 副作用，数据变化后，effect 重新执行。组件、computed、watch 都是局域 effect 来实现的（视图）

副作用函数 默认执行一次，里面的响应式数据改变的时候，会再次执行当前 副作用函数

1. reactive 方法中如果不是对象，就直接返回当前对象；如果是对象就进行代理
2. 边界处理
   + 如果同一个对象代理两次，不用重复的代理。利用全局缓存，记录代理后的结果，（WeakMap）key：tagert value: 代理后的对象
   + 代理生成的 proxy，又在传入 reactive 里面，再次进行代理，应该使用之前的数据。利用代理之后，proxy 里面一定会有 get 方法，在 get 方法进行判断，使用足够特殊的 key，访问到了当前 key 就 return true；在进行代理的前一步进行 当前对象.特殊key 的访问，如果得到的是 true 的话，就说明传入的是一个已经通过代理返回的 proxy 对象了，返回当前对象就可以了
   > 注意，这种方法并没有像对象上添加任何额外的属性，只是对读操作进行了劫持
3. 读响应式属性的时候，让响应式属性和副作用函数映射起来；赋值响应式属性的时候，重新执行该属性对应的副作用函数
   利用 Reflect 代理读取操作（主要是为了结局 对象中存在 get 时的 this 指向问题）
   + 依赖收集
   + 触发更新
4. effect 接收一个 fn、options 
   定义一个副作用包裹类，接收副作用函数 fn 和一个调度去（决定何时，如何执行 fn） 里面有一个方法 run，执行传递过来的副作用函数
   当执行 fn 的时候，要在 get 中收集当前的包装副作用实例，这样就要有一个全局变量 activeEffect 在执行 fn 前，将当前的包装副作用实例保存好，执行完了 fn 之后，activeEffect 重置为 undefined
   处理嵌套的 effct 中的 activeEffect 的值（可以利用 栈）



## 处理副作用函数中是有条件分支的情况
第一次执行的时候，会读取到 state.a，但是第二次执行的时候，不会读取 state.a 由于之前 state.a 关于这个副作用函数的依赖没有被清除，所以 state.a 改变的时候，依旧会执行该副作用函数，不能出现这种情况