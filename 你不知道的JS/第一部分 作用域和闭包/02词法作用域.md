- [词法作用域](#词法作用域)
  - [词法阶段](#词法阶段)
  - [欺骗词法](#欺骗词法)
    - [eval](#eval)
    - [with](#with)
    - [性能](#性能)

# 词法作用域
作用域 是一套规则，用来管理 引擎 如何在当前作用域以及嵌套的子作用域中根据变量名查找变量

作用域有两个主要工作模型：
1. 词法作用域（最普遍的）
2. 动态作用域

## 词法阶段
大部分标准语言 编译器 的第一个工作阶段叫作 词法化（分词/词法分析）
词法作用域 就是定义在 词法阶段 的作用域
词法作用域 是由你在写代码时将变量和块写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况下是这样的）
注意：词法作用域 一般在写代码的时候就已经确定了，无论在哪里使用，无论怎么使用，一般其 词法作用域 都不会变

注意函数的参数，与函数内部的作用域是一起的

作用域 查找会在找到第一个匹配的标识符时停止

## 欺骗词法
虽然是 词法作用域 是在代码书写期间就确定了的，但是还是有方法在 运行是时 修改
欺骗词法作用域 会导致性能下降
两种方法 eval 和 with

### eval
eval(str);
str 会被转化成代码执行，eval 写在哪里，string 代表的那段代码的 词法作用域 就在哪里
严格模式下 eval 有自己的 词法作用域
```js
let b = 3;
function foo(str, a) {
  evel(str);
  console.log(a, b); // 非严格模式下 1, 2；严格模式下 1，3
};
foo('let b = 2', 1);
```

### with
严格模式下，完全禁用 with

通常被当做重复引用同一个对象中的多个属性的快捷方式，可以不重复引用对象本身
在固定的 词法作用域 中去进行操作，如果在 with 所代表的 词法作用域 中没有找到{}内的内容，就会向上层作用域查找

这个块内部正常的var声明并不会被限制在这个块的作用域中，而是被添加到with所处的函数作
用域中

```js
let obj = {
  a: 1,
  b: 2,
  c: 3,
};
with (obj) {
  a = 11;
  b = 22;
  c = 33;
  d = 44;
} 
```

### 性能
eval(..) 和 with() {} 会在运行时修改或创建新的作用域