- [作用域是什么](#作用域是什么)
  - [编译原理](#编译原理)
  - [理解作用域](#理解作用域)
  - [作用域嵌套](#作用域嵌套)
  - [异常](#异常)

# 作用域是什么
需要一套设计良好的规则来存储变量，并且之后可以方便的找到这些变量。这套规则被称作*作用域*
（作用域（Scope）是指变量、函数和对象的可访问性。换句话说，作用域决定了代码中哪些部分可以访问变量，以及变量在代码中的生命周期）

## 编译原理
js 是一门*编译语言*，但是它和其他的语言不同，它不是提前编译的

传统语言中编译分为三个阶段：
1. 分词/词法分析（Tokenizing/Lexing）
   将字符串分解成有意义的发吗块，这些代码块称之为词法单元（token）
2. 解析/语法分析（Parsing）
   将词法单元流（数组）转换成一个代表了程序语法结构的树：“抽象语法树”（Abstract Syntax Tree，AST）
3. 代码生成
   AST 转化成可执行代码的过程

任何 JavaScript 代码片段在执行前都要进行编译（通常就在执行前很短的事件内）

## 理解作用域
+ 引擎
  从头到尾负责整个 JavaScript 程序的 编译 及 执行 过程
+ 编译器
  负责 语法分析 及 代码生成 等
+ 作用域
  负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限
  （收集和维护变量的查询，确定当前的代码对变量的访问权限）

```js
var a = 2;
```
引擎认为是 两个 不用的声明 var a; a = 2 ：
1. 一个由 编译器 在 编译时 处理
2. 一个由 引擎 在 运行时 处理

实际处理：
1. 编译器 询问 作用域 是否已经有了一个该名称的变量存在于同一作用域的集合中；如果没有 编译器 会要求 作用域 在当前作用域集合 中声明一个新变量，命名为 a
2. 编译器 生成运行时代码，用来处理 a = 2 这个赋值操作。引擎 运行时首先会询问 作用域，当前的作用域集合中是否有 a 变量，如果有，就会使用这个变量，将 2 赋值给 a，如果没有会沿着作用域链查找，如果最后都没有找到， 引擎 会抛出错误

在第二点中，引擎与作用域协同，引擎会对变量 a 进行 LHS 查询（查找的变量在赋值操作的左侧）
LHS查询：试图找到变量的容器本身，从而可以对其赋值。
RHS查询：与简单地查找某个变量的值别无二致

## 作用域嵌套
作用域 是根据名称查找变量的一套规则

当一个块或者函数嵌套在另一个块或者函数中时，就发生了作用域嵌套

## 异常
区分 LHS 和 RHS（非左侧） 是很重要的
这两种情况下，对于沿着作用域链到最后都未查找到变量的行为不一样
RHS 会抛出 ReferenceError
LHS 如果是非严格模式，会在顶层作用域中创建一个该同名变量，如果是在严格模式下，也会抛出错误

如果 RHS 查找到了，但是进行不恰当的操作，会抛 TypeError（例如：null.a null()）
