- [作用域闭包](#作用域闭包)
  - [启示](#启示)
  - [实质问题](#实质问题)
  - [现在我懂了](#现在我懂了)
  - [循环和闭包](#循环和闭包)
  - [模块](#模块)
    - [现代的模块机制](#现代的模块机制)
    - [未来的模块机制](#未来的模块机制)

# 作用域闭包

## 启示
闭包是基于词法作用域书写代码时所产生的自然结果

## 实质问题
当函数可以 记住并访问 所在的 词法作用域 时，就产生了 闭包，即使函数是在当前 词法作用域 之外执行

```js
function foo() {
  var a = 2;
    function bar() {
    console.log( a );
    }
  return bar;
}
var baz = foo();
baz(); // 2
```
在 foo() 执行后，通常会期待 foo() 的整个内部作用域都被销毁，因为我们知道引擎有垃圾回收器用来释放不再使用的内存空间。由于看上去 foo() 的内容不会再被使用，所以很自然地会考虑对其进行回收
而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此没有被回收

## 现在我懂了
## 循环和闭包
## 模块
### 现代的模块机制
### 未来的模块机制