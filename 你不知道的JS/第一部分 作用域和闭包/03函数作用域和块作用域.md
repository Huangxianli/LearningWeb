- [函数作用域和块作用域](#函数作用域和块作用域)
  - [函数中的作用域](#函数中的作用域)
  - [隐藏内部实现](#隐藏内部实现)
  - [函数作用域](#函数作用域)
    - [匿名和具名](#匿名和具名)
    - [立即执行函数表达式](#立即执行函数表达式)
  - [块作用域](#块作用域)
    - [with](#with)
    - [try/catch](#trycatch)
    - [let](#let)
    - [const](#const)

# 函数作用域和块作用域

## 函数中的作用域
函数作用域 的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）

## 隐藏内部实现
从所写的代码中挑选出一个任意的片段，然后用函数声明对它进行包装，实际上就是把这些代码“隐藏”起来了
最小授权 或 最小暴露 原则

## 函数作用域
在任意代码片段外部添加包装函数，可以将内部的变量和函数定义“隐藏”起来，外部作用域无法访问包装函数内部的任何内容
如果函数不需要函数名（或者至少函数名可以不污染所在作用域），并且能够自动运行，这将会更加理想

(function foo() { ... })()
会被当作 函数表达式 而不是一个标准的 函数声明 来处理

区分 函数声明 和 表达式 最简单的方法是看 function 关键字出现在声明中的位置（不仅仅是一行代码，而是整个声明中的位置）。如果 function 是声明中的第一个词，那么就是一个 函数声明，否则就是一个 函数表达式

函数声明 和 函数表达式 之间最重要的区别是它们的 名称标识符 将会绑定在何处
函数表达式 绑定在自身的函数，而不是所在的作用域中，拿上面的 foo 来说，foo 只能在 { ... } 中被访问，不能在当前 作用域 中访问。这样变量 foo 就不会污染当前 作用域

### 匿名和具名
匿名函数表达式：setTimeout(function() {})；函数表达式可以省略函数名的，函数声明不可以省略函数名

匿名有缺点：
1. 调试困难，调用栈中不会有名称
2. 递归中只能 arguments.callee 调用自己
3. 不能一眼看出函数的作用

始终给函数表达式命名：setTimeout(function timeoutHandler() {});

### 立即执行函数表达式
```js
(function foo() {
  let a = 12;
  console.log(a); // 12
})();
```
立即执行函数 有称为 IIFE，立即执行函数表达式

## 块作用域
### with
with 中定义的变量，只能在 {} 内使用，是块级作用域的一种形式

### try/catch
catch 分句会创建一个块级作用域，() 中的变量，只能在当前 块作用域 中访问

### let
let 关键字可以将变量绑定到所在的任意作用域中（通常是{ .. }内部）

只要声明是有效的，在声明中的任意位置都可以使用{ .. }括号来为let创建一个用于绑定的块

1. 垃圾收集
2. let 循环
   ```js
   for (let i = 0; i < 10; i++) {
    // ...
   }
   ```
   这种写法使得，i 重新绑定 到了循环的每一个 迭代 中

### const
了const，同样可以用来创建块作用域变量，但其值是固定的（常量）。之后任何试图修改值的操作都会引起错误。

