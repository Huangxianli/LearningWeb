# 事件循环
## 浏览器的多线程 和 js 的单线程
浏览器是多线程的

js 是单线程的 但是 是非阻塞的，遇到异步的代码，不会阻塞在这里，如何实现的，就是依靠 事件循环
目的：js 可以操作 dom，但是如果两个线程同时执行，而且同时操作一个 dom，如何处理，就很有一样的操作，在多次的运行中，得到的结果是不一样的

当引擎第一次遇到 JS 代码时，会产生一个全局执行上下文并压入执行栈，每遇到一个函数调用，就会往栈中压入一个新的上下文。引擎执行栈顶的函数，执行完毕，弹出当前执行上下文

可以粗略的认为，所有的 js 代码都会在执行栈中执行

同步任务，会进入主线程中，主线程中的任务会进入执行栈中执行
异步任务，会进入事件队列中，当同步任务执行完成之后，微任务会被放入执行栈中去执行；执行完了，又会去宏任务队列中取一个任务宏任务执行，如果其中产生了微任务则执行完这一个宏任务之后，就去执行新产生的微任务，直到所有的任务执行完

## 事件循环的过程
> 一次事件循环 是一个宏任务执行的开始，到 下一个宏任务的开始

1. 将这个脚本作为一个 宏任务
2. 宏任务进入宏任务队列，微任务进入微任务队列（注意只有在满足条件的时候，才会进入队列）
3. 当前最前面一个宏任务执行完出队，执行当前宏任务时，如果产生了微任务，push 进微任务队列，当前宏任务执行后，读取微任务列表，有则依次执行，直到全部执行完
4. 执行浏览器的 UI 渲染
5. 如果有 WebWork 则执行
6. 执行完本轮宏任务，回到 2，直到所有的宏任务和微任务都执行完

### 宏任务
+ script(整体代码)
+ setTimeout/setInterval
+ I/O
+ UI 渲染
+ postMessage
+ MessageChannel
+ requestAnimationFrame（不同的浏览器加入宏任务的时机可能不同）
+ setImmediate(Node.js 环境)
### 微任务
+ new Promise().then() （catch 和 catch 也是微任务）如果有几个 then 会是第一个 then 加入为任务，然后等到第一个then 执行完了之后，再将第二个 then 放入微任务队列
+ await 这一条语句后的后面的语句
+ MutaionObserver
+ process.nextTick (Node.js 环境）


